from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, RedirectResponse
from pydantic import BaseModel
from typing import List, Dict, Optional
import json
import os
import datetime
from supabase import create_client, Client
from dotenv import load_dotenv
from fpdf import FPDF
import uuid

load_dotenv()

app = FastAPI(title="ShieldCall AI Backend", version="3.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")
supabase: Client = None

if url and key:
    try:
        supabase = create_client(url, key)
        print("âœ… Connected to Supabase Database")
    except Exception as e:
        print(f"âš ï¸ Database Connection Failed: {e}")

# --- Models ---
class TextAnalysisRequest(BaseModel):
    text: str

class ReportRequest(BaseModel):
    victim_name: str
    scammer_phone: str
    scam_type: str
    description: str
    evidence_text: str

# --- WebSocket Manager (Existing) ---
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.device_map: Dict[WebSocket, Dict] = {}

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        if self.device_map:
            await websocket.send_json({"type": "DEVICE_LIST_UPDATE", "devices": list(self.device_map.values())})

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections: self.active_connections.remove(websocket)
        if websocket in self.device_map: del self.device_map[websocket]

    async def broadcast(self, message: Dict):
        # Iterate over a COPY of the list to allow safe removal during iteration
        for connection in list(self.active_connections):
            try: await connection.send_json(message)
            except: self.disconnect(connection)

manager = ConnectionManager()

# --- NEW: PDF Generator ---
class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 15)
        self.cell(0, 10, 'CYBER CRIME INCIDENT REPORT', 0, 1, 'C')
        self.ln(5)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Generated by ShieldCall AI - Page {self.page_no()}', 0, 0, 'C')

@app.post("/report/generate")
async def generate_report(req: ReportRequest):
    pdf = PDF()
    pdf.add_page()
    
    # Title Section
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt=f"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=1, align='R')
    pdf.ln(10)
    
    # To Address
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, "To,", ln=1)
    pdf.cell(0, 10, "The Nodal Officer,", ln=1)
    pdf.cell(0, 10, "Cyber Crime Cell / National Cyber Crime Reporting Portal,", ln=1)
    pdf.cell(0, 10, "Government of India.", ln=1)
    pdf.ln(10)
    
    # Subject
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, f"Subject: Complaint regarding {req.scam_type} attempt from {req.scammer_phone}", ln=1)
    pdf.ln(10)
    
    # Body
    pdf.set_font("Arial", size=12)
    body = (
        f"Respected Sir/Madam,\n\n"
        f"I, {req.victim_name}, would like to report a suspected fraud attempt targeting me.\n\n"
        f"Details of the Suspect:\n"
        f"- Phone Number: {req.scammer_phone}\n"
        f"- Modus Operandi: {req.scam_type}\n\n"
        f"Incident Description:\n{req.description}\n\n"
        f"Transcript/Evidence Captured by ShieldCall AI:\n"
        f"---------------------------------------------------\n"
        f"\"{req.evidence_text}\"\n"
        f"---------------------------------------------------\n\n"
        f"I request you to take necessary action against this number to prevent further financial loss to citizens.\n\n"
        f"Sincerely,\n"
        f"{req.victim_name}\n"
        f"Generated via ShieldCall App"
    )
    pdf.multi_cell(0, 10, body)
    
    filename = f"report_{uuid.uuid4()}.pdf"
    pdf.output(filename)
    
    return FileResponse(filename, filename="CyberCrime_Complaint.pdf")

@app.get("/report_mobile_landing")
async def report_mobile_landing(request: Request):
    """
    Redirects mobile users to the Web Dashboard Report Page by guessing the host IP.
    Assumes Frontend is running on port 5173.
    """
    host = request.url.hostname
    if not host or host == "0.0.0.0":
        host = "localhost"
    
    # Redirect to the frontend Report page
    return RedirectResponse(url=f"http://{host}:5173/report")

# --- NEW: Text Analysis ---
@app.post("/analyze/text")
def analyze_text(req: TextAnalysisRequest):
    text = req.text.lower()
    
    # NLP / Keyword Logic (Mocking sophisticated NLP for now)
    scam_patterns = {
        "urgeny": ["immediately", "urgent", "24 hours", "blocked", "suspend"],
        "financial": ["bank", "account", "kyc", "pan", "aadhar", "credit card", "limit"],
        "action": ["click", "link", "download", "apk", "install", "pay", "transfer"]
    }
    
    detected_patterns = []
    risk = 0
    
    for category, keywords in scam_patterns.items():
        found = [w for w in keywords if w in text]
        if found:
            detected_patterns.extend(found)
            risk += (len(found) * 15)
            
    risk = min(99, risk)
    
    verdict = "SAFE"
    if risk > 40: verdict = "SUSPICIOUS"
    if risk > 75: verdict = "MALICIOUS"
    
    return {
        "risk_score": risk,
        "verdict": verdict,
        "patterns": list(set(detected_patterns))
    }

# --- NEW: Blacklist Module ---
blacklist_memory = {
    "+919876543210", "+919988776655", "+918888888888", "+917777766666", "+919123456789"
}

class BlacklistRequest(BaseModel):
    phone: str
    reason: str
    reported_by: str

@app.get("/blacklist/check")
def check_blacklist(phone: str):
    is_blacklisted = False
    details = "Number is safe."
    
    # 1. Check Supabase
    if supabase:
        try:
            res = supabase.table('blacklist').select("*").eq("phone_number", phone).execute()
            if res.data and len(res.data) > 0:
                is_blacklisted = True
                details = f"Reported {len(res.data)} times. Flagged as Scam."
        except:
            pass # Fallback to memory
            
    # 2. Check Memory (Fallback/Demo)
    if not is_blacklisted and phone in blacklist_memory:
        is_blacklisted = True
        details = "Flagged in local database."
        
    return {"phone": phone, "is_blacklisted": is_blacklisted, "details": details}

@app.post("/blacklist/report")
def report_blacklist(req: BlacklistRequest):
    # 1. Add to Supabase
    if supabase:
        try:
            supabase.table('blacklist').insert({
                "phone_number": req.phone,
                "reason": req.reason,
                "reported_by": req.reported_by,
                "created_at": datetime.datetime.now().isoformat()
            }).execute()
        except Exception as e:
            print(f"Supabase Error: {e}")
            
    # 2. Add to Memory
    blacklist_memory.add(req.phone)
    
    # 3. Notify Connected Clients (Live Update)
    # We can broadcast a 'NEW_BLACKLIST_REPORT' event if needed
    
    return {"status": "success", "message": f"Reported {req.phone} to global blacklist."}

@app.get("/blacklist/list")
def list_blacklist():
    # 1. Supabase
    if supabase:
        try:
            res = supabase.table('blacklist').select("*").order("created_at", desc=True).limit(50).execute()
            return res.data
        except: pass
        
    # 2. Memory Fallback
    # convert set to list of objects
    return [{"phone_number": p, "reason": "Local Block", "reported_by": "System", "created_at": datetime.datetime.now().isoformat()} for p in blacklist_memory]

@app.get("/devices")
def get_devices():
    return list(manager.device_map.values())

@app.get("/stats")
def get_stats():
    scams = 0
    blocked = 0
    protected = len(manager.device_map) # + some base count if desired
    
    if supabase:
        try:
            # Note: count='exact', head=True is efficient way to get count without fetching data
            # But supabase-py syntax varies. Using simple select for now or hardcoded simulation if needed.
            # Assuming small scale for demo.
            r1 = supabase.table('reports').select("id", count='exact').execute()
            r2 = supabase.table('blacklist').select("id", count='exact').execute()
            
            scams = r1.count if r1.count is not None else len(r1.data)
            blocked = r2.count if r2.count is not None else len(r2.data)
        except:
            scams = 12 # Mock fallback
            blocked = len(blacklist_memory)

    return {
        "scams": scams,
        "protected": max(protected, 1), # At least 1 if empty
        "blocked": blocked
    }

# --- NEW: Threat History Module ---
threat_memory = [] # Fallback storage

@app.get("/threats/recent")
def get_recent_threats():
    # 1. Try Supabase
    if supabase:
        try:
            res = supabase.table('reports').select("*").order("created_at", desc=True).limit(50).execute()
            # Map proper keys if needed, assuming direct mapping for now
            return [{"id": r['id'], "phone": r['phone_number'], "scam_type": r['scam_type'], "risk_score": r['risk_score'], "transcript_snippet": r['transcript'], "timestamp": r['created_at']} for r in res.data]
        except: pass
        
    # 2. Fallback Memory
    return sorted(threat_memory, key=lambda x: x['timestamp'], reverse=True)[:50]

# --- Existing Endpoints (Stats, WS, etc) ---
# ... (Keeping previous WebSocket logic intact)
@app.websocket("/ws/monitor")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    print(f"ðŸ”Œ WS Connected: {websocket.client}")
    try:
        while True:
            data = await websocket.receive_text()
            # print(f"ðŸ“© WS Received: {data[:50]}...") # Log first 50 chars
            message = json.loads(data)
            
            if message.get('type') == 'REGISTER_DEVICE':
                print(f"ðŸ“± Device Registered: {message.get('device_name')} ({message.get('device_id')})")
                manager.device_map[websocket] = {
                    "id": message.get('device_id'),
                    "name": message.get('device_name', 'Unknown Android'),
                    "battery": message.get('battery', 100),
                    "threats_blocked": message.get('threats_blocked', 0),
                    "status": "ONLINE",
                    "last_seen": datetime.datetime.now().isoformat()
                }
                print(f"ðŸ“Š Current Devices: {list(manager.device_map.values())}")
                await manager.broadcast({"type": "DEVICE_LIST_UPDATE", "devices": list(manager.device_map.values())})

            elif message.get('type') == 'AUDIO_CHUNK':
                if websocket in manager.device_map:
                    manager.device_map[websocket]['status'] = "ANALYZING..." 
                    await manager.broadcast({"type": "DEVICE_LIST_UPDATE", "devices": list(manager.device_map.values())})

                text = message.get('text', '').lower()
                scam_words = ["otp", "cvv", "lottery", "pay", "bank", "police", "refund", "card", "password", "urgent"]
                matches = sum(1 for word in scam_words if word in text)
                
                # Make detection more aggressive for demonstration
                risk_score = 0
                if matches > 0:
                    risk_score = 85 + (matches * 10) # Instant high alert if any keyword found
                elif "hello" in text or "hi" in text:
                    risk_score = 10 

                
                if risk_score > 50:
                    payload = {
                        "type": "NEW_THREAT",
                        "phone": manager.device_map.get(websocket, {}).get('name', 'Mobile Client'),
                        "scam_type": message.get('scam_type', 'Voice Phishing'),
                        "risk_score": min(99, risk_score),
                        "transcript_snippet": message.get('text'),
                        "timestamp": datetime.datetime.now().isoformat()
                    }
                    await manager.broadcast(payload)
                    
                    # Store in Memory (Fallback)
                    threat_memory.append(payload)
                    
                    if supabase:
                        try:
                            supabase.table('reports').insert({
                                "phone_number": payload['phone'],
                                "scam_type": payload['scam_type'],
                                "risk_score": payload['risk_score'],
                                "transcript": payload['transcript_snippet'],
                                "created_at": payload['timestamp']
                            }).execute()
                        except: pass

    except WebSocketDisconnect:
        manager.disconnect(websocket)
