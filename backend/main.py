from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, RedirectResponse
from pydantic import BaseModel
from typing import List, Dict, Optional
import json
import os
import datetime
from supabase import create_client, Client
from dotenv import load_dotenv
from fpdf import FPDF
import uuid

load_dotenv()

app = FastAPI(title="ShieldCall AI Backend", version="3.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")
supabase: Client = None

if url and key:
    try:
        supabase = create_client(url, key)
        print("âœ… Connected to Supabase Database")
    except Exception as e:
        print(f"âš ï¸ Database Connection Failed: {e}")

# --- Models ---
class TextAnalysisRequest(BaseModel):
    text: str

class ReportRequest(BaseModel):
    victim_name: str
    scammer_phone: str
    scam_type: str
    description: str
    evidence_text: str

# --- WebSocket Manager (Existing) ---
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.device_map: Dict[WebSocket, Dict] = {}

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        if self.device_map:
            await websocket.send_json({"type": "DEVICE_LIST_UPDATE", "devices": list(self.device_map.values())})

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections: self.active_connections.remove(websocket)
        if websocket in self.device_map: del self.device_map[websocket]

    async def broadcast(self, message: Dict):
        # Iterate over a COPY of the list to allow safe removal during iteration
        for connection in list(self.active_connections):
            try: await connection.send_json(message)
            except: self.disconnect(connection)

manager = ConnectionManager()

# --- NEW: PDF Generator ---
class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 15)
        self.cell(0, 10, 'CYBER CRIME INCIDENT REPORT', 0, 1, 'C')
        self.ln(5)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Generated by ShieldCall AI - Page {self.page_no()}', 0, 0, 'C')

@app.post("/report/generate")
async def generate_report(req: ReportRequest):
    try:
        pdf = PDF()
        pdf.add_page()
        
        # Title Section
        pdf.set_font("Arial", size=12)
        pdf.cell(200, 10, txt=f"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=1, align='R')
        pdf.ln(10)
        
        # To Address
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(0, 10, "To,", ln=1)
        pdf.cell(0, 10, "The Nodal Officer,", ln=1)
        pdf.cell(0, 10, "Cyber Crime Cell / National Cyber Crime Reporting Portal,", ln=1)
        pdf.cell(0, 10, "Government of India.", ln=1)
        pdf.ln(10)
        
        # Subject - sanitize special characters
        subject = f"Subject: Complaint regarding {req.scam_type} attempt from {req.scammer_phone}"
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(0, 10, subject.encode('latin-1', 'replace').decode('latin-1'), ln=1)
        pdf.ln(10)
        
        # Body - sanitize special characters (â‚¹ -> Rs, etc)
        pdf.set_font("Arial", size=12)
        
        # Clean the input text (replace Unicode chars that Arial can't handle)
        clean_desc = req.description.replace('â‚¹', 'Rs.').replace('â€”', '-').replace('"', '"').replace('"', '"')
        clean_evidence = req.evidence_text.replace('â‚¹', 'Rs.').replace('â€”', '-').replace('"', '"').replace('"', '"')
        clean_name = req.victim_name.encode('latin-1', 'replace').decode('latin-1')
        
        body = (
            f"Respected Sir/Madam,\n\n"
            f"I, {clean_name}, would like to report a suspected fraud attempt targeting me.\n\n"
            f"Details of the Suspect:\n"
            f"- Phone Number: {req.scammer_phone}\n"
            f"- Modus Operandi: {req.scam_type}\n\n"
            f"Incident Description:\n{clean_desc}\n\n"
            f"Transcript/Evidence Captured by ShieldCall AI:\n"
            f"---------------------------------------------------\n"
            f"\"{clean_evidence}\"\n"
            f"---------------------------------------------------\n\n"
            f"I request you to take necessary action against this number to prevent further financial loss to citizens.\n\n"
            f"Sincerely,\n"
            f"{clean_name}\n"
            f"Generated via ShieldCall App"
        )
        pdf.multi_cell(0, 10, body.encode('latin-1', 'replace').decode('latin-1'))
        
        filename = f"report_{uuid.uuid4()}.pdf"
        pdf.output(filename)
        
        return FileResponse(filename, filename="CyberCrime_Complaint.pdf", media_type="application/pdf")
    except Exception as e:
        print(f"PDF Generation Error: {e}")
        raise HTTPException(status_code=500, detail=f"PDF generation failed: {str(e)}")

@app.get("/report_mobile_landing")
async def report_mobile_landing(request: Request):
    """
    Redirects mobile users to the Web Dashboard Report Page by guessing the host IP.
    Assumes Frontend is running on port 5173.
    """
    host = request.url.hostname
    if not host or host == "0.0.0.0":
        host = "localhost"
    
    # Redirect to the frontend Report page
    return RedirectResponse(url=f"http://{host}:5173/report")

# --- NEW: Text Analysis ---
@app.post("/analyze/text")
def analyze_text(req: TextAnalysisRequest):
    text = req.text.lower()
    
    # NLP / Keyword Logic - Comprehensive scam detection
    scam_patterns = {
        "urgency": ["immediately", "urgent", "24 hours", "blocked", "suspend", "expires", "deadline"],
        "financial": ["bank", "account", "kyc", "pan", "aadhar", "credit card", "limit", "otp", "password"],
        "action": ["click", "link", "download", "apk", "install", "pay", "transfer", "deposit", "send"],
        "lottery": ["lottery", "prize", "won", "winner", "congratulations", "lakh", "crore", "lucky", "claim"],
        "threat": ["police", "arrest", "court", "customs", "legal", "case", "warrant"]
    }
    
    detected_patterns = []
    risk = 0
    
    for category, keywords in scam_patterns.items():
        found = [w for w in keywords if w in text]
        if found:
            detected_patterns.extend(found)
            risk += (len(found) * 15)
            
    risk = min(99, risk)
    
    verdict = "SAFE"
    if risk > 40: verdict = "SUSPICIOUS"
    if risk > 75: verdict = "MALICIOUS"
    
    return {
        "risk_score": risk,
        "verdict": verdict,
        "patterns": list(set(detected_patterns))
    }

# --- JSON File Storage for Offline Persistence ---
DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
BLACKLIST_FILE = os.path.join(DATA_DIR, "blacklist.json")
THREATS_FILE = os.path.join(DATA_DIR, "threats.json")

def ensure_data_dir():
    if not os.path.exists(DATA_DIR):
        os.makedirs(DATA_DIR)

def load_json_file(filepath, default):
    ensure_data_dir()
    if os.path.exists(filepath):
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return default
    return default

def save_json_file(filepath, data):
    ensure_data_dir()
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

# Initialize from files (persistent across restarts)
blacklist_data = load_json_file(BLACKLIST_FILE, [])
threat_memory = load_json_file(THREATS_FILE, [])

class BlacklistRequest(BaseModel):
    phone: str
    reason: str
    reported_by: str

def normalize_phone(phone: str) -> str:
    """Normalize phone number for comparison - remove spaces, dashes, and ensure consistent format"""
    # Remove all non-digit characters except +
    cleaned = ''.join(c for c in phone if c.isdigit() or c == '+')
    # If it's just digits, add +91 prefix for Indian numbers
    if cleaned and not cleaned.startswith('+'):
        if len(cleaned) == 10:
            cleaned = '+91' + cleaned
        elif len(cleaned) == 12 and cleaned.startswith('91'):
            cleaned = '+' + cleaned
    return cleaned

@app.get("/blacklist/check")
def check_blacklist(phone: str):
    is_blacklisted = False
    details = "Number is safe."
    report_count = 0
    
    # Normalize the input phone
    normalized_input = normalize_phone(phone)
    
    # 1. Check Supabase
    if supabase:
        try:
            res = supabase.table('blacklist').select("*").eq("phone_number", phone).execute()
            if res.data and len(res.data) > 0:
                is_blacklisted = True
                report_count = len(res.data)
                details = f"Reported {report_count} times. Flagged as Scam."
        except:
            pass
            
    # 2. Check JSON File (Fallback) - Compare normalized versions
    if not is_blacklisted:
        matches = [b for b in blacklist_data if normalize_phone(b.get("phone_number", "")) == normalized_input]
        if matches:
            is_blacklisted = True
            report_count = len(matches)
            details = f"Reported {report_count} times. Flagged in local database."
        
    return {"phone": phone, "is_blacklisted": is_blacklisted, "details": details, "report_count": report_count}

@app.post("/blacklist/report")
def report_blacklist(req: BlacklistRequest):
    global blacklist_data
    
    new_entry = {
        "phone_number": req.phone,
        "reason": req.reason,
        "reported_by": req.reported_by,
        "created_at": datetime.datetime.now().isoformat()
    }
    
    # 1. Add to Supabase
    if supabase:
        try:
            supabase.table('blacklist').insert(new_entry).execute()
        except Exception as e:
            print(f"Supabase Error: {e}")
            
    # 2. Add to JSON file
    blacklist_data.append(new_entry)
    save_json_file(BLACKLIST_FILE, blacklist_data)
    
    return {"status": "success", "message": f"Reported {req.phone} to global blacklist."}

@app.get("/blacklist/list")
def list_blacklist():
    # 1. Supabase
    if supabase:
        try:
            res = supabase.table('blacklist').select("*").order("created_at", desc=True).limit(50).execute()
            return res.data
        except: pass
        
    # 2. JSON Fallback (sorted by created_at descending)
    sorted_list = sorted(blacklist_data, key=lambda x: x.get('created_at', ''), reverse=True)
    return sorted_list[:50]

@app.get("/devices")
def get_devices():
    return list(manager.device_map.values())

@app.get("/stats")
def get_stats():
    scams = len(threat_memory)  # Use JSON-backed threat_memory
    blocked = len(blacklist_data)
    protected = len(manager.device_map)
    
    if supabase:
        try:
            r1 = supabase.table('reports').select("id", count='exact').execute()
            r2 = supabase.table('blacklist').select("id", count='exact').execute()
            
            scams = r1.count if r1.count is not None else len(r1.data)
            blocked = r2.count if r2.count is not None else len(r2.data)
        except:
            pass  # Use JSON fallback counts

    return {
        "scams": scams,
        "protected": max(protected, 1),
        "blocked": blocked
    }

@app.get("/threats/recent")
def get_recent_threats():
    # 1. Try Supabase
    if supabase:
        try:
            res = supabase.table('reports').select("*").order("created_at", desc=True).limit(50).execute()
            return [{"id": r['id'], "phone": r['phone_number'], "scam_type": r['scam_type'], "risk_score": r['risk_score'], "transcript_snippet": r['transcript'], "timestamp": r['created_at']} for r in res.data]
        except: pass
        
    # 2. JSON Fallback
    return sorted(threat_memory, key=lambda x: x.get('timestamp', ''), reverse=True)[:50]

# --- Existing Endpoints (Stats, WS, etc) ---
# ... (Keeping previous WebSocket logic intact)
@app.websocket("/ws/monitor")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    print(f"ðŸ”Œ WS Connected: {websocket.client}")
    try:
        while True:
            data = await websocket.receive_text()
            # print(f"ðŸ“© WS Received: {data[:50]}...") # Log first 50 chars
            message = json.loads(data)
            
            if message.get('type') == 'REGISTER_DEVICE':
                print(f"ðŸ“± Device Registered: {message.get('device_name')} ({message.get('device_id')})")
                manager.device_map[websocket] = {
                    "id": message.get('device_id'),
                    "name": message.get('device_name', 'Unknown Android'),
                    "battery": message.get('battery', 100),
                    "threats_blocked": message.get('threats_blocked', 0),
                    "status": "ONLINE",
                    "last_seen": datetime.datetime.now().isoformat()
                }
                print(f"ðŸ“Š Current Devices: {list(manager.device_map.values())}")
                await manager.broadcast({"type": "DEVICE_LIST_UPDATE", "devices": list(manager.device_map.values())})

            elif message.get('type') == 'AUDIO_CHUNK':
                if websocket in manager.device_map:
                    manager.device_map[websocket]['status'] = "ANALYZING..." 
                    await manager.broadcast({"type": "DEVICE_LIST_UPDATE", "devices": list(manager.device_map.values())})

                text = message.get('text', '').lower()
                scam_words = ["otp", "cvv", "lottery", "pay", "bank", "police", "refund", "card", "password", "urgent"]
                matches = sum(1 for word in scam_words if word in text)
                
                # Make detection more aggressive for demonstration
                risk_score = 0
                if matches > 0:
                    risk_score = 85 + (matches * 10) # Instant high alert if any keyword found
                elif "hello" in text or "hi" in text:
                    risk_score = 10 

                
                if risk_score > 50:
                    payload = {
                        "type": "NEW_THREAT",
                        "id": str(uuid.uuid4()),
                        "phone": manager.device_map.get(websocket, {}).get('name', 'Mobile Client'),
                        "scam_type": message.get('scam_type', 'Voice Phishing'),
                        "risk_score": min(99, risk_score),
                        "transcript_snippet": message.get('text'),
                        "timestamp": datetime.datetime.now().isoformat()
                    }
                    await manager.broadcast(payload)
                    
                    # Store in JSON (Persistent)
                    threat_memory.append(payload)
                    save_json_file(THREATS_FILE, threat_memory)
                    
                    if supabase:
                        try:
                            supabase.table('reports').insert({
                                "phone_number": payload['phone'],
                                "scam_type": payload['scam_type'],
                                "risk_score": payload['risk_score'],
                                "transcript": payload['transcript_snippet'],
                                "created_at": payload['timestamp']
                            }).execute()
                        except: pass

    except WebSocketDisconnect:
        manager.disconnect(websocket)
